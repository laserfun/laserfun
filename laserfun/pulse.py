"""Tools for working with laser pulses."""

import numpy as np
import scipy.fftpack as fft
import scipy
import matplotlib.pyplot as plt

# speed of light in m/s and nm/ps
c_mks = 299792458.0
c_nmps = c_mks * 1e9 / 1e12


class Pulse:
    """Generate a new pulse object based on a pre-defined pulse shapes.

    Customized pulses can be generated by calling this function and then
    manually setting the time- or frequency domain pulse-profile using
    ``pulse.at`` or ``pulse.aw``.

    Note that the pulse object is intrinsically a single laser pulse, and the
    time and frequency domain electric fields refer to the single pulse, not
    the average power of the laser at some repetition rate. The `
    `power_is_avg`` and ``frep_MHz`` values are used only to set the electric
    field during the generation of the pulse and are not stored in the pulse
    object.

    Parameters
    ----------
    pulse_type : string
        The shape of the pulse in the time domain. Options are:

        - sech, which produces a hyperbolic secant (sech) shaped pulse
          ``A(t) = sqrt(power) * sech(t/T0)``, where ``T0=fwhm/1.76``
        - gaussian, which produces a Gaussian shaped pulse
          ``A(t) = sqrt(power) * exp(-(t/T0)^2/2)``, where ``T0=fwhm/1.76``
        - sinc, which uses a sin(x)/x (sinc) function
          ``A(t) = sqrt(power) * sin(t/T0)/(t/T0)``, were ``T0=fwhm/3.79``

    center_wavelength_nm : float
        The center wavelength of the pulse in nm.
    fwhm_ps : float
        The full-width-at-half-maximum of the pulse in picoseconds.
    time_window_ps : float
        The time window in picoseconds. This is the full-width of the time
        window, so the times will go from ``-time_window_ps * 0.5`` to
        + ``time_window_ps * 0.5``.
    power : float
        this is either the peak power of the pulse or the average power of
        the pulse-train, depending on ``power_is_avg``. In both cases the units
        are in watts.
    epp : float or None
        the energy-per-pulse in Joules. If this is not None (the default),
        then this overrides the power argument to set the pulse energy.
    npts : int
        the number of points in the time and frequency grids. Using powers
        of 2 might be beneficial for the efficiency of the FFTs in the
        NLSE algorithm. ``2**12`` is a good starting point.
    power_is_avg : boolean
        determines if the power is peak power or average power. Note that this
        value is only used for calculating the initial pulse amplitude and is
        not saved as an intrinsic characteristic of the pulse object.
    frep_MHz : float
        the repetition rate in MHz. Used for setting the peak power of the
        pulse to match the average power of the pulse train. Similar to
        ``power_is_avg``, the rep rate is not saved as part of the pulse class.
    GDD : float
        the group-delay-dispersion (in ps^2) to apply to the pulse.
    TOD : float
        the third-order dispersion (in ps^3) to apply to the pulse.
    FOD : float
        the fourth-order dispersion (in ps^3) to apply to the pulse.
    """

    def __init__(
        self,
        pulse_type="sech",
        center_wavelength_nm=1550,
        fwhm_ps=0.2,
        time_window_ps=10.0,
        power=1.0,
        epp=None,
        npts=2**12,
        power_is_avg=False,
        frep_MHz=100,
        GDD: float = 0.0,
        TOD: float = 0.0,
        FOD=0,
    ):

        self.npts = npts
        self.center_wavelength_nm = center_wavelength_nm
        self.time_window_ps = time_window_ps

        if pulse_type == "sech":
            # from https://www.rp-photonics.com/sech2_shaped_pulses.html
            self.at = np.sqrt(power) / np.cosh(self.t_ps / (fwhm_ps / 1.76))

        elif pulse_type == "gaussian":
            # from https://www.rp-photonics.com/gaussian_pulses.html
            self.at = np.sqrt(power) * np.exp(
                -2.77 * 0.5 * self.t_ps**2 / ((fwhm_ps) ** 2)
            )

        elif pulse_type == "sinc":
            T0_ps = fwhm_ps / 3.7909885  # previously: T0_ps = FWHM_ps/3.7909885
            # numpy.sinc is sin(pi*x)/(pi*x), so we divide by pi
            self.at = np.sqrt(power) * np.sinc(self.t_ps / ((fwhm_ps / 2.783) * np.pi))

        else:
            raise ValueError("Pulse type not recognized.")

        if power_is_avg:
            self.at = self.at * np.sqrt(power / (frep_MHz * 1.0e6 * self.epp))

        if epp is not None:
            self.epp = epp

        if pulse_type in ["sech", "gaussian", "sinc"]:
            self.chirp_pulse_W(GDD, TOD, FOD)

    # FUNDAMENTAL PROPERTIES
    # These are the 4 fundamental properties that describe the pulse.
    # Everything else is derived from these.
    # Note that underscores are used for the actual variables (self._npts),
    # while self.npts redirects to the getter/setter methods.

    # 1. npts:
    @property
    def npts(self):
        """Set/get Number of points (int) in the time (and frequency) grid."""
        return self._npts

    @npts.setter
    def npts(self, new_npts):
        self._npts = int(new_npts)

    # 2. center frequency/wavelength:
    @property
    def centerfrequency_THz(self):
        """Set/get The center frequency (float) of the pulse in THz."""
        return self._centerfrequency_THz

    @centerfrequency_THz.setter
    def centerfrequency_THz(self, new_centerfrequency):
        assert new_centerfrequency > 1.0
        self._centerfrequency_THz = new_centerfrequency

    # 3. time window:
    @property
    def time_window_ps(self):
        """Set/get the time window of the time grid in picoseconds (float)."""
        return self._time_window_ps

    @time_window_ps.setter
    def time_window_ps(self, time_window_ps):
        self._time_window_ps = time_window_ps

    # 4. amplitude in frequency domain:
    @property
    def aw(self):
        """Set/get the complex amplitude of the pulse in the frequency domain.

        Corresponds to the frequencies in the pulse.aw array. Note that this
        is the complex amplitude and that the intensity is the square of the
        absolute value.

        The units are sqrt(W) or sqrt(J)*sqrt(Hz), so abs(aw)^2 * deltaF will
        provide J/bin. (90% sure this comment about units is correct.)
        """
        return self._aw

    @aw.setter
    def aw(self, aw_new):
        if "self._aw" not in locals():  # if aw doesn't exist, make blank array
            self._aw = np.zeros((self._npts,), dtype=np.complex128)
        self._aw[:] = aw_new

    # DERIVED PROPERTIES:

    # center angular frequency
    @property
    def w0_THz(self):
        """Get the center *angular* frequency (THz)."""
        return 2.0 * np.pi * self._centerfrequency_THz

    # center wavelength:
    @property
    def center_wavelength_nm(self):
        """Set/get the center wavelength of the grid in units of nanometers."""
        return c_nmps / self._centerfrequency_THz

    @center_wavelength_nm.setter
    def center_wavelength_nm(self, wl):
        self.centerfrequency_THz = c_nmps / wl

    # frequency grid
    @property
    def v_THz(self):
        """Get the *relative* *angular* frequency grid in THz."""
        return (
            2.0
            * np.pi
            * np.arange(-self.npts / 2, self.npts / 2)
            / (self.npts * self.dt_ps)
        )

    @property
    def w_THz(self):
        """Get the absolute *angular* frequency grid (THz)."""
        return self.v_THz + self.w0_THz

    @property
    def f_THz(self):
        """Get the absolute frequency grid in THz."""
        return (self.v_THz + self.w0_THz) / (2 * np.pi)

    # wavelength grid:
    @property
    def wavelength_nm(self):
        """Wavelength grid in nanometers."""
        return c_nmps / self.f_THz

    # time grid:
    @property
    def t_ps(self):
        """Get the temporal grid in ps."""
        return np.linspace(
            -self._time_window_ps / 2.0,
            self._time_window_ps / 2.0,
            self._npts,
            endpoint=False,
        )

    # dt:
    @property
    def dt_ps(self):
        """Return time grid spacing in ps."""
        return self._time_window_ps / np.double(self._npts)

    @property
    def df_THz(self):
        """Frequency grid spacing in THz."""
        f_THz = self.f_THz
        return f_THz[1] - f_THz[0]

    # amplitude in the time domain:
    @property
    def at(self):
        """Amplitude of the time-domain electric field (complex).

        Units are ``sqrt(W)``, which can be considered ``sqrt(J)/sqrt(s)``,
        so units of energy per time bin when the absolute value is squared.
        """
        return IFFT(self._aw.copy())

    @property
    def it(self):
        """Amplitude of the time-domain intensity.

        Units are ``watts``.
        """
        return np.abs(self.at) ** 2

    @at.setter
    def at(self, at_new):
        self.aw = FFT(at_new)

    # epp, energy per pulse:
    @property
    def epp(self):
        """Energy per pulse in Joules."""
        return (self.dt_ps * 1e-12) * np.trapz(abs(self.at) ** 2)

    @epp.setter
    def epp(self, desired_epp_J):
        self.at = self.at * np.sqrt(desired_epp_J / self.epp)

    # intensity in various units
    def psd(self, units="W", rep_rate=1):
        """Return the power spectral density (PSD) in various units. Set the
        rep_rate to 1 to get "per pulse" units. Otherwise, the rep-rate will be
        used to scale the per-pulse numbers to average power units. By default,
        the rep-rate of the pulse object is used.

        Unit options are:

        ``'mW'``, mW for each data point. (Not actually PSD units.)
        ``'mW/THz'``, mW per THz.
        ``'dBm/THz'``, 10*log10(mW) per THz.
        ``'mW/nm'``, mW per nanometer.
        ``'dBm/nm'``, 10*log10(mW) per nanometer.

        Note that for the "per nanometer" units, the data is still delivered on
        a grid that is evenly spaced in *frequency*, not wavelength. So, if
        integrating the PSD, it is necessary to take into account the changing
        size of the wavelength bins to recover the correct value for the
        average power. The psd_wavelength function provides both the evenly
        spaced wavelength grid and the y-axis unit conversion.

        Parameters
        ----------
        units : str
            Determines the units of the intensity of power-spectral-density.
            See above for options.
        rep_rate : float
            Determines the repetition rate (in Hz) used to calculate the PSD.
            Set to 1 to get per-pulse PSD. If ``None``, then the rep-rate for
            the pulse object will be used. Note that the rep-rate provided to
            this function doesn't change the rep-rate of the pulse object, it
            is merely used for the PSD calculation.


        Returns
        -------
        psd : array
            numpy array of power spectral densities corresponding to pulse.aw.


        """

        if rep_rate == 1:
            print("Note: the rep-rate is set to 1; per-pulse values returned.")

        # Note: all units are calculated since these calculations are easy.

        # per bin units:
        f = self.f_THz
        df = (f[1] - f[0]) * 1e12  # df in Hz
        J_Hz = np.abs(self.aw) ** 2
        J_per_bin = J_Hz / df  # go from J*Hz/bin (native units) to J/bin
        # multiply by rep rate to get W/bin, and then mW/bin:
        mW_per_bin = J_per_bin * rep_rate * 1e3

        # per THz units:
        mW_per_THz = mW_per_bin / (df * 1e-12)
        dBm_per_THz = 10 * np.log10(mW_per_THz)

        # per wavelength units
        wl_nm = c_nmps / f
        wl_m = wl_nm * 1e-9
        nm_per_bin = wl_m**2 / 3e8 * df * 1e9  # Jacobian from THz to nm
        mW_per_nm = mW_per_bin / nm_per_bin  # convert to mW/nm
        dBm_per_nm = 10 * np.log10(mW_per_nm)  # convert to dBm/nm

        # return the requested PSD:
        if units == "mW/bin":
            return mW_per_bin
        elif units == "mW/THz":
            return mW_per_THz
        elif units == "dBm/THz":
            return dBm_per_THz
        elif units == "mW/nm":
            return mW_per_nm
        elif units == "dBm/nm":
            return dBm_per_nm
        else:
            raise ValueError("Units not recognized.")

    def psd_wavelength(self, wl_min=500, wl_max=2500, wl_step=0.2):
        """-- Not yet implemented --
        evenly spaced wavelength and intensity in various units"""

        pass

    def clone_pulse(self, p):
        """Copy all parameters of pulse_instance into this one."""
        self.npts = p.npts
        self.centerfrequency_THz = p.centerfrequency_THz
        self.time_window_ps = p.time_window_ps
        self.aw = p.aw

    def create_cloned_pulse(self):
        """Create and return new pulse instance identical to this instance."""
        p = Pulse()
        p.clone_pulse(self)
        return p

    def add_noise(self, noise_type="sqrt_N_freq"):
        """Add random intensity and phase noise to a pulse.

        Parameters
        ----------
        noise_type : string
            The method used to add noise. The options are:

            - ``sqrt_N_freq`` : adds noise to each bin in the frequency domain.
              The average noise added is proportional to sqrt(N), and where N
              is the number of photons in that frequency bin.

            - ``one_photon_freq``` : which adds one photon of noise to each
              frequency bin.
        """
        # Get the number of photons/second in each frequency bin:
        size_of_bins = self.df_THz * 1e-12  # Bin width in [Hz]
        power_per_bin = np.abs(self.aw) ** 2 / size_of_bins  # [J*Hz]/[Hz] = [J]

        h = 6.62607004e-34

        photon_energy = h * self.f_THz * 1e-12  # h nu [J]
        photons_per_bin = power_per_bin / photon_energy  # photons / second
        photons_per_bin[photons_per_bin < 0] = 0  # must be positive.

        # now generate some random intensity and phase arrays:
        size = np.shape(self.aw)[0]
        random_intensity = np.random.normal(size=size)
        random_phase = np.random.uniform(size=size) * 2 * np.pi

        if noise_type == "sqrt_N_freq":
            # Gaussian noise with sqrt(photons_per_bin)
            noise = (
                random_intensity
                * np.sqrt(photons_per_bin)
                * photon_energy
                * size_of_bins
                * np.exp(1j * random_phase)
            )

        elif noise_type == "one_photon_freq":  # one photon per bin
            noise = (
                random_intensity
                * photon_energy
                * size_of_bins
                * np.exp(1j * random_phase)
            )
        else:
            raise ValueError("noise_type not recognized.")

        self.aw = self.aw + noise

    def chirp_pulse_W(self, GDD: float, TOD: float = 0, FOD=0.0, w0_THz=None):
        r"""Alter the phase of the pulse.

        Apply the dispersion coefficients :math:`\beta_2, \beta_3, \beta_4`
        expanded around frequency :math:`\omega_0`.

        Parameters
        ----------
        GDD : float
            Group delay dispersion (:math:`\beta_2`) [ps^2]
        TOD : float, optional
            Group delay dispersion (:math:`\beta_3`) [ps^3], defaults to 0.
        FOD : float, optional
            Group delay dispersion (:math:`\beta_4`) [ps^4], defaults to 0.
        w0_THz : float, optional
            Center freq. of dispersion expansion, defaults to grid center freq.

        Notes
        -----
        The convention used for dispersion is

        .. math:: E_{new} (\omega) = \exp\left(i \left(
           \frac{1}{2} GDD\, \omega^2 + \frac{1}{6}\, TOD \omega^3 +
           \frac{1}{24} FOD\, \omega^4 \right)\right) E(\omega)
        """
        if w0_THz is None:
            self.aw = (
                np.exp(
                    1j * (GDD / 2.0) * self.v_THz**2
                    + 1j * (TOD / 6.0) * self.v_THz**3
                    + 1j * (FOD / 24.0) * self.v_THz**4
                )
                * self.aw
            )
        else:
            V = self.w_THz - w0_THz
            self.aw = (
                np.exp(
                    1j * (GDD / 2.0) * V**2
                    + 1j * (TOD / 6.0) * V**3
                    + 1j * (FOD / 24.0) * V**4
                )
                * self.AW
            )

    def calc_width(self, level=0.5):
        """Calculate the pulse width.

        For example, the full-width-at-half-maxmimum
        (FWHM) or the 1/e width. If the pulse has multiple crossings (for example,
        if it reaches the 0.5 level multiple times) the widest extent will be
        returned.

        Parameters
        ----------
        level : float
            the fraction of the peak to calculate the width.
            Must be between 0 and 1.
            Default is 0.5, which provides the FWHM.
            1/e = 0.367879
            1/e^2 = 0.135335

        Returns
        -------
        width : float
            the width of the pulse in picoseconds.
        """

        def find_roots(x, y):
            s = np.abs(np.diff(np.sign(y))).astype(bool)
            return x[:-1][s] + np.diff(x)[s] / (np.abs(y[1:][s] / y[:-1][s]) + 1)

        it = np.abs(self.at) ** 2
        it = it / np.max(it)
        roots = find_roots(self.t_ps, it - level)
        width = np.max(roots) - np.min(roots)
        return width

    def transform_limit(self):
        """ "Return a transform-limited pulse (flat spectral phase)."""
        newpulse = self.create_cloned_pulse()
        newpulse.aw = np.abs(newpulse.aw)
        return newpulse

    def plot_spectrogram(
        self,
        gate_type="xfrog",
        gate_function_width_ps=0.020,
        time_steps=500,
        wavelength_or_frequency="frequency",
        ylabels_of_interest=[],
    ):
        """


        Parameters
        ----------
        gate_type : TYPE, optional
            DESCRIPTION. The default is 'xfrog'.
        gate_function_width_ps : TYPE, optional
            DESCRIPTION. The default is 0.020.
        time_steps : TYPE, optional
            DESCRIPTION. The default is 500.
        wavelength_or_frequency : TYPE, string
            plots the spectrogram in frequency or wavelength domain. The default is 'frequency'
        ylabels_of_interest
            Wavelengtsh or frequencies of interest that are plotted as horizontal lines overlaying the spectrogramm.Defaults to []
        Returns
        -------
        None.

        """

        # Call spectrogram
        DELAYS, FREQS_OR_WLS, extent, spectrogram = self.spectrogram(
            gate_type=gate_type,
            gate_function_width_ps=gate_function_width_ps,
            time_steps=time_steps,
            wavelength_or_frequency=wavelength_or_frequency,
        )

        AT = self.at
        t_ps = self.t_ps

        # Set up the figure and axes
        fig, (ax0, ax1) = plt.subplots(
            2, 1, figsize=(8, 8), gridspec_kw={"height_ratios": [1, 2]}, sharex=True
        )

        # Plot initial and final time-domain pulses
        ax0.plot(t_ps, np.abs(AT), label="Pulse")
        ax0.set_xlabel("Time (ps)")
        ax0.set_ylabel("Amplitude (a.u.)")
        ax0.legend()

        # Plot the spectrogram
        im = ax1.imshow(
            np.abs(spectrogram),
            aspect="auto",
            extent=extent,
            origin="lower",
            cmap="viridis",
        )

        if wavelength_or_frequency == "frequency":
            ax1.set_ylabel("Frequency (THz)")

            # Add white dashed lines at the specified wavelengths of interest
            for wl in ylabels_of_interest:
                ax1.axhline(y=wl, color="white", linestyle="--", linewidth=1)
                # 60nm is just a manual shift of the text.
                ax1.text(
                    x=extent[1] - 0.6,
                    y=wl + 10,
                    s=f"{wl} THz",
                    color="white",
                    verticalalignment="center",
                )

        elif wavelength_or_frequency == "wavelength":
            ax1.set_ylabel("Wavelength (nm)")

            # Add white dashed lines at the specified wavelengths of interest
            for wl in ylabels_of_interest:
                ax1.axhline(y=wl, color="white", linestyle="--", linewidth=1)
                # 60nm is just a manual shift of the text.
                ax1.text(
                    x=extent[1] - 0.5,
                    y=wl + 60,
                    s=f"{wl} nm",
                    color="white",
                    verticalalignment="center",
                )

        else:
            raise ValueError(
                'wavelength_or_frequency must be either "wavelength" or "frequency"'
            )

        ax1.set_xlabel("Time (ps)")

        ax1.xaxis.set_tick_params(labelbottom=True)
        ax0.xaxis.set_tick_params(labelbottom=True)
        ax0.grid(True, which="both")

        plt.tight_layout()
        plt.show()
        return fig, (ax0, ax1)

    def spectrogram(
        self,
        gate_type="xfrog",
        gate_function_width_ps=0.020,
        time_steps=500,
        wavelength_or_frequency="frequency",
    ):
        """This calculates the spectrogram of the pulse, which is a 2D plot of
        the time versus the frequnecy. It can be used to visualize where
        different spectral components are located in time.

        The pulse can either be compared with a gaussian reference pulse
        (XFROG) or to itself (FROG). Here, FROG refers to the "frequency
        resolved optical gating" experiment. The temporal width of the pulse
        for the XFROG is set by the "gate_function_width_ps" parameter.

        See Dudley Fig. 10, on p1153 for a description
        of the XFROG spectrogram in the context of supercontinuum generaiton.
        (http://dx.doi.org/10.1103/RevModPhys.78.1135)

        Alternatively, the gate_type can be set to 'frog', which simulates a
        SHG-FROG measurement, where the pulse is probed with a copy of itself,
        in an autocorrelation fashion. Interpreting this FROG spectrogram is
        less intuitive, so this is mainly useful for comparison with
        experimental  FROG spectra (which are often easier to acquire than
        XFROG measurements.)

        A nice discussion of various FROG "species" is available here:
        http://frog.gatech.edu/tutorial.html

        Parameters
        ----------
        gate_type : string
            Determines the type of gate function. Can be either 'xfrog' or
            'frog'. Should likely be set to 'xfrog' unless comparing with
            experiments. Default is 'xfrog'.
        gate_function_width : float
            the width of the gate function in seconds. Only applies when
            gate_type='xfrog'. A shorter duration provides better temporal
            resolution, but worse spectral resolution, so this is a trade-off.
            Typically, 0.01 to 0.1 ps works well.
        time_steps : int
            the number of delay time steps to use. More steps makes a higher
            resolution spectrogram, but takes longer to process and plot.
            Default is 500
        wavelength_or_frequency: str
            Default is 'frequency'

        Returns
        -------
        DELAYS : 2D numpy meshgrid
            the columns have increasing delay (in ps)
        FREQS : 2D numpy meshgrid
            the rows have increasing frequency (in THz)
        spectrogram : 2D numpy array
            Following the convention of Dudley, the frequency runs along the
            y-axis (axis 0) and the time runs along the x-axis (axis 1)

        Example
        -------
        The spectrogram can be visualized using something like this: ::

            import matplotlib.pyplot as plt
            plt.figure()
            DELAYS, FREQS, extent, spectrogram = pulse.spectrogram()
            plt.imshow(spectrogram, aspect='auto', extent=extent)
            plt.xlabel('Time (ps)')
            plt.ylabel('Frequency (THz)')
            plt.tight_layout

            plt.show()

        output:

        .. image:: https://cloud.githubusercontent.com/assets/1107796/13677657/25075ea4-e6a8-11e5-98b4-7813fa9a6425.png
           :width: 500px
           :alt: example_result
        """

        def gauss(x, A=1, mu=0, sigma=1):  # gaussian function
            return A * np.exp(-((x - mu) ** 2) / (2.0 * sigma**2))

        t = self.t_ps  # working in ps

        delay = np.linspace(np.min(t), np.max(t), time_steps)
        D, T = np.meshgrid(delay, t)
        D, AT = np.meshgrid(delay, self.at)

        phase = np.unwrap(np.angle(AT))
        amp = np.abs(AT)

        if gate_type == "xfrog":
            gate_function = gauss(T, mu=D, sigma=gate_function_width_ps)
        elif gate_type == "frog":
            dstep = float(delay[1] - delay[0])
            tstep = float(t[1] - t[0])

            # calculate the coordinates of the new array
            dcoord = D * 0
            tcoord = (T - D - np.min(T)) / tstep

            gate_function_real = scipy.ndimage.interpolation.map_coordinates(
                np.real(AT), (tcoord, dcoord)
            )
            gate_function_imag = scipy.ndimage.interpolation.map_coordinates(
                np.imag(AT), (tcoord, dcoord)
            )
            gate_function = gate_function_real + 1j * gate_function_imag

        else:
            raise ValueError(
                'Type ""%s"" not recognized. Type must be "xfrog" or "frog".'
                % gate_type
            )

        # make a 2D array of E(time, delay)
        E = amp * gate_function * np.exp(1j * (phase))

        spectrogram = np.fft.ifft(E, axis=0)
        spectrogram = np.fft.fftshift(spectrogram, axes=0)

        freqs = np.fft.fftfreq(np.shape(E)[0], t[1] - t[0])
        freqs = np.fft.fftshift(freqs)
        freqs = freqs + self.centerfrequency_THz

        DELAYS, FREQS = np.meshgrid(delay, freqs)

        if wavelength_or_frequency == "frequency":
            # calculate the extent to make it easy to plot:
            extent = (np.min(DELAYS), np.max(DELAYS), np.min(FREQS), np.max(FREQS))
            return DELAYS, FREQS, extent, np.abs(spectrogram)

        elif wavelength_or_frequency == "wavelength":
            # Convert frequencies to wavelengths

            frequencies_THz = FREQS[:, 1]
            # this is just a frequency vector for the interpolation because innterpolation requires increasing values (https://numpy.org/doc/stable/reference/generated/numpy.interp.html)
            # the interpoloation is therefore done on a "new frequency grid" that corresponds to the equidistant wavelength grid.

            # Define the new wavelength grid
            wl_min = (
                self.center_wavelength_nm / 2.5
            )  # some arbitrary boundaries covering > octave
            wl_max = self.center_wavelength_nm * 2.5

            wavelength_grid = np.linspace(wl_min, wl_max, np.shape(FREQS)[0])
            new_frequencies_grid = (
                c_nmps / wavelength_grid
            )  # this is just for the interpolation to have an increasing grid.

            # Interpolate spectrogram data onto the new frequency grid that corresponds to the desired wavelength grid
            spectrogram_interpolated = np.zeros(
                (len(wavelength_grid), np.shape(spectrogram)[1])
            )

            for i in range(np.shape(spectrogram)[1]):
                spectrogram_interpolated[:, i] = np.interp(
                    new_frequencies_grid, frequencies_THz, np.abs(spectrogram[:, i])
                )

            WAVELENGTHS, DELAYS = np.meshgrid(wavelength_grid, delay)
            extent = (
                np.min(DELAYS),
                np.max(DELAYS),
                np.min(wavelength_grid),
                np.max(wavelength_grid),
            )
            return DELAYS, WAVELENGTHS, extent, spectrogram_interpolated

        else:
            raise ValueError(
                'wavelength_or_frequency must be either "wavelength" or "frequency"'
            )


def FFT(A, ax=0):
    """Perform a forward fast Fourier transform (FFT) to take an array of 
    amplitudes in the TIME domain and transform them to the FREQUENCY domain.
    
    This function performs the FT, as well as the initial and final fftshifts.
    The function of the final ifftshift is the usual shifting of the FT output
    to put the zero frequency components back in the center. The function of
    the initial fftshift is perhaps less obvious, but it is necessary in order
    to take a time signal with a real peak in the center and return a frequency
    spectrum with all-real components.
    
    In other words, we take a "human readable" time domain array, flip it into
    the weird zero-at-the-edges format that the FFT likes, do the FFT, then 
    flip the signal back. Confused? You're not alone.

    Note that this function uses np.fft.ifft, the inverse fft function, while 
    it purports to perform a forward FFT. The secret to this brain-breaking
    madness can be found on Page 45 of Dudley's book "Supercontinuum Generation
    in Optical Fibers" (Cambridge, 2010) and as described here:
    https://github.com/laserfun/laserfun/issues/73
    The convention chosen for the NLSE FTs flips the usual convention, using
    the forward FFT to go from frequency to time.
    
    Parameters
    ----------
    A : numpy array, n-dimensional
        The TIME domain data to be Fourier transformed. The transform will only
        be performed along one axis. 
    ax : int
        The axis that the FT should be performed along. Defaults to 0.
    
    Returns
    -------
    FT : numpy array, same dimensions as A 
        the fourier-transformed data, now in the FREQUENCY domain. 
    """
        
    A = A.astype("complex128")
    FT = fft.ifftshift(fft.ifft(fft.fftshift(A, axes=(ax,)), axis=ax), axes=(ax,))
    return FT


def IFFT(A, ax=0):
    """Perform an *inverse* FT to take an array of amplitudes in the FREQUENCY
    domain and transform them to the TIME domain.
    
    See documentation for FFT_t"""
    
    A = A.astype("complex128")
    IFT = fft.ifftshift(fft.fft(fft.fftshift(A, axes=(ax,)), axis=ax), axes=(ax,))
    return IFT
